#include <set>

using namespace std;

// TYPEN
struct wandel {
    int pos1;
    int fig;
};
union zug {
    struct {
        char pos1 : 8;
        char pos2 : 8;
    }   pos;
    int id : 16;
};
struct denkpaar {
    zug    z;
    int    farbe;
    int    figur;
    int    spezial;
    int    bewertung;
    int    i;
    wandel verwandelung[20];
    int    nw;
    bool   reckoning;
    bool   kill;

    int finds[120]; // Find
};

struct figurtyp {
    int  pos1;
    int  pos2;
    bool schach;
    bool bewegt;
};
struct feldtyp  {
    int feld[120];
    int x;
};

int eigene_farbe = 1;  // Sicht des Computers --1-0
int stopp        = 5;  // normale Suchtiefe, wird ver‚Ä∞ndert
const int ende   = 15; // maximale Suchtiefe
int sortiertiefe = 15; // Sortiertiefe - wieviele Z¬∏ge werden sortiert


int KooIch       = 300;
int KooEr        = 50;
double AttackIch = 5;
double AttackEr  = 6; //HIER
int    DefIch1   = 40;
int    DefIch2   = 80;
double DefEr     = 17; //
int    MobDame   = 5; //
double AttDame   = 0.11;
int    MobTurm   = 8;
double AttTurm   = 0.5;
double MobLau    = 8;
double AttLau    = 0.75;
double AttSpr    = 0.75;
double AttBau    = 3.5; ////
double AttKoe    = 0.4;
//int Koenigsangriff_Ich = 25;
//int Koenigsangriff_Er = 25;  //25 Koenigsangriff_Ich


enum state { user, uci, gone, position };
state status = uci;

// const char _DEFAULT_PATH[] = "partie";

const int figurenanzahl = 12; // bei disp()
bool killFlag           = true;
const int MAX_WERT      = 99999999;


enum howitends      { matt       = -MAX_WERT, patt = -1, remis = 0, schaach = 1,
    schachmatt = +MAX_WERT, nothing };
enum espezial           { NICHTS = 0, SCHACH = 1, UNRUH = 2 };
enum spiel_status   { Eroeffnung, Mittelspiel, Spaetspiel, Endspiel };
const char *spiel_status_namen[] = {
        "Eroeffnung", "Mittelspiel", "Mittel-Endspiel", "Endspiel"
};
enum figuren            { // bei disp()
    S_Tr = -12, S_Kr = -11,
    S_K  = -10, S_D, S_T, S_L,
    S_P, S_B, S_Bu, S_Bp_r, S_Bp_l, S_Bx,
    LEER                                                     = 0,
    W_Bx, W_Bp_l, W_Bp_r, W_Bu, W_B, W_P, W_L, W_T, W_D, W_K = 10, W_Kr = 11,
    W_Tr                                                     = 12,
    RAND                                                     = 13
};

const char *figuren_char[] = { // bei disp()
        "tmr", "knr", "kon", "dam", "tum", "laf", "pdf", "bau", "baU", "bar", "bal",
        "bax",
        ".",
        "BAX", "BAL", "BAR", "BAu", "BAU", "PDF", "LAF", "TUM", "DAM", "KON", "KNR",
        "TMR", "RAND" };

// bei eingabe()
const char *figuren_intern[] =       { // bei writ()
        "S_Tr",   "S_Kr",     "S_K",      "S_D",      "S_T",      "S_L",      "S_P",
        "S_B",
        "S_Bu",
        "S_Bp_r", "S_Bp_l",   "S_Bx",
        "LEER",
        "W_Bx",   "W_Bp_l",   "W_Bp_r",   "W_Bu",     "W_B",      "W_P",      "W_L",
        "W_T",
        "W_D",
        "W_K",    "W_Kr",     "W_Tr",
        "RAND" };

char buchstaben1[] =       { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };
char buchstaben2[] =       { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };
char zahlen[]      =       { '1', '2', '3', '4', '5', '6', '7', '8' };

const char *grundfeld_bezeichnungen[120] = {
        // Ausgabe der Felder
        "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND",
        "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND",
        "RAND", "a1",   "b1",   "c1",   "d1",   "e1",   "f1",   "g1",   "h1",   "RAND",
        "RAND", "a2",   "b2",   "c2",   "d2",   "e2",   "f2",   "g2",   "h2",   "RAND",
        "RAND", "a3",   "b3",   "c3",   "d3",   "e3",   "f3",   "g3",   "h3",   "RAND",
        "RAND", "a4",   "b4",   "c4",   "d4",   "e4",   "f4",   "g4",   "h4",   "RAND",
        "RAND", "a5",   "b5",   "c5",   "d5",   "e5",   "f5",   "g5",   "h5",   "RAND",
        "RAND", "a6",   "b6",   "c6",   "d6",   "e6",   "f6",   "g6",   "h6",   "RAND",
        "RAND", "a7",   "b7",   "c7",   "d7",   "e7",   "f7",   "g7",   "h7",   "RAND",
        "RAND", "a8",   "b8",   "c8",   "d8",   "e8",   "f8",   "g8",   "h8",   "RAND",
        "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND",
        "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND", "RAND",
        "RAND" };

/*int grundfeld[120] =
{ RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
RAND, LEER, LEER, W_K, LEER, LEER,  LEER,  LEER,  W_D,   RAND,
RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
RAND, LEER, LEER, S_K, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND };//*/
/*int grundfeld[120] =
{ RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
  RAND, W_Tr, LEER, LEER, LEER, W_Kr,  LEER,  LEER,  W_Tr,   RAND,
  RAND, W_Bx, W_Bx, W_Bx, LEER, LEER,  LEER,  W_Bx,  LEER,   RAND,
  RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  W_B,   RAND,
  RAND, LEER, LEER, LEER, LEER, W_B,    W_B,  LEER,  LEER,   RAND,
  RAND, LEER, LEER, S_B,  W_P,  S_P,  LEER,  W_L,  LEER,   RAND,
  RAND, S_B, S_D, LEER, S_B, LEER,  LEER,  LEER,  S_B,   RAND,
  RAND, LEER, S_Bx, LEER, LEER, LEER,  S_Bx,  S_Bx,  LEER,   RAND,
  RAND, S_Tr, LEER,  LEER,  LEER,  S_Kr,  S_L,  LEER,   S_Tr,   RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND };//*/
int grundfeld[120] =
        { RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
          RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
          RAND, W_Tr, W_P,  W_L,  W_D,  W_Kr,  W_L,   W_P,   W_Tr,   RAND,
          RAND, W_Bx, W_Bx, W_Bx, W_Bx, W_Bx,  W_Bx,  W_Bx,  W_Bx,   RAND,
          RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
          RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
          RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
          RAND, LEER, LEER, LEER, LEER, LEER,  LEER,  LEER,  LEER,   RAND,
          RAND, S_Bx, S_Bx, S_Bx, S_Bx, S_Bx,  S_Bx,  S_Bx,  S_Bx,   RAND,
          RAND, S_Tr, S_P,  S_L,  S_D,  S_Kr,  S_L,   S_P,   S_Tr,   RAND,
          RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND,
          RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,   RAND }; // */


/*
   bool in_array(const std::string &value, const std::vector<string> &array)
   {
    return std::find(array.begin(), array.end(), value) != array.end();
   }

   void readCSV(istream &input, vector< vector<string> > &output)
   {
   string csvLine;
    // read every line from the stream
    while( getline(input, csvLine) )
    {
            istringstream csvStream(csvLine);
           vector<string> csvColumn;
            string csvElement;
            // read every element from the line that is seperated by commas
            // and put it into the vector or strings
            while( getline(csvStream, csvElement, ',') )
            {
                    csvColumn.push_back(csvElement);
            }
            output.push_back(csvColumn);
    }
   }
 */

/*int grundfeld[120] =
   {RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
                         RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
                         RAND,	W_Tr,	LEER,	W_L,	W_D,	W_Kr,	W_L,	LEER,	W_Tr,	RAND,
                         RAND,	W_Bx,	W_Bx,	W_Bx,	LEER,	LEER,	W_Bx,	W_Bx,	W_Bx,	RAND,
                         RAND,	LEER,	LEER,	W_P,	LEER,	LEER,	W_P,	LEER,	LEER,	RAND,
                         RAND,	LEER,	S_P,	LEER,	LEER,	LEER,	LEER,	LEER,	LEER,	RAND,
                         RAND,	LEER,	LEER,	LEER,	W_B,	LEER,	LEER,	LEER,	LEER,	RAND,
                         RAND,	LEER,	LEER,	LEER,	LEER,	LEER,	S_P,	LEER,	LEER,	RAND,
                         RAND,	S_Bx,	S_Bx,	S_Bx,	S_Bx,	S_D,	S_Bx,	S_Bx,	S_Bx,	RAND,
                         RAND,	S_Tr,	LEER,	S_L,	LEER,	S_Kr,	S_L,	LEER,	S_Tr,	RAND,
                         RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
                         RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};

   /*                BEWERTUNG                 */
int __STARTFELD[120] = // Wei√üer Bauer
        { RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, LEER, LEER, LEER, LEER, LEER, LEER, LEER, LEER, RAND,
          RAND, W_Bx, W_Bx, W_Bx, W_Bx, W_Bx, W_Bx, W_Bx, W_Bx, RAND,
          RAND, W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  RAND,
          RAND, W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  RAND,
          RAND, W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  RAND,
          RAND, W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  RAND,
          RAND, W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  W_B,  RAND,
          RAND, LEER, LEER, LEER, LEER, LEER, LEER, LEER, LEER, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx[120] = // Schwarzer Bauer
        { RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, LEER, LEER, LEER, LEER, LEER, LEER, LEER, LEER, RAND,
          RAND, S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  RAND,
          RAND, S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  RAND,
          RAND, S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  RAND,
          RAND, S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  RAND,
          RAND, S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  S_B,  RAND,
          RAND, S_Bx, S_Bx, S_Bx, S_Bx, S_Bx, S_Bx, S_Bx, S_Bx, RAND,
          RAND, LEER, LEER, LEER, LEER, LEER, LEER, LEER, LEER, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx2[120] = // Wei√üer Springer
        { RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  W_P,  RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx3[120] = // Schwarzer Springer
        { RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  S_P,  RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
          RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
/*int __STARTFELDx4[120] = // Wei√üer L√§ufer
{ RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  W_L,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx5[120] = // Schwarzer L√§ufer
{ RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  S_L,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
/*int __STARTFELDx6[120] = // Wei√üer Turm
{ RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  W_T,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx7[120] = // Schwarzer Turm
{ RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  S_T,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx8[120] = // Wei√üe Dame
{ RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  W_D,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx9[120] = // Schwarze Dame
{ RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  S_D,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND,
  RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND, RAND };
int __STARTFELDx10[120] = // Wei√üer K√∂nig
{ RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_Kr,  W_K,   W_K,   W_K,   RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_K,   W_K,   W_K,   W_K,   RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_K,   W_K,   W_K,   W_K,   RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_K,   W_K,   W_K,   W_K,   RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_K,   W_K,   W_K,   W_K,   RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_K,   W_K,   W_K,   W_K,   RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_K,   W_K,   W_K,   W_K,   RAND,
  RAND, W_K,  W_K,  W_K,  W_K,  W_K,   W_K,   W_K,   W_K,   RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND };
int __STARTFELDx11[120] = // Schwarzer K√∂nig
{ RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_K,   S_K,   S_K,   S_K,   RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_K,   S_K,   S_K,   S_K,   RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_K,   S_K,   S_K,   S_K,   RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_K,   S_K,   S_K,   S_K,   RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_K,   S_K,   S_K,   S_K,   RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_K,   S_K,   S_K,   S_K,   RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_K,   S_K,   S_K,   S_K,   RAND,
  RAND, S_K,  S_K,  S_K,  S_K,  S_Kr,  S_K,   S_K,   S_K,   RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND,
  RAND, RAND, RAND, RAND, RAND, RAND,  RAND,  RAND,  RAND,  RAND };//*/


int __STARTPUNKTEx[120] = // Wei√üe bauern
        { RAND, RAND,  RAND,  RAND,   RAND,  RAND,  RAND,  RAND, RAND,  RAND,
          RAND, RAND,  RAND,  RAND,   RAND,  RAND,  RAND,  RAND, RAND,  RAND,
          RAND, 0,     0,     0,      0,     0,  	0,     0,    0,     RAND,
          RAND, 8,     16,    24,     32,    32,	24,    16,   8,     RAND,
          RAND, 3,     12,    20,     28,    28,    20,    12,   3,     RAND,
          RAND, -5,    4,     10,     20,    20,    10,    4,    -5,    RAND,
          RAND, -6,    4,     5,      16,    16,    5,     4,    -6,    RAND,
          RAND, -6,    4,     2,      5,     5,     2,     4,    -6,    RAND,
          RAND, -6,    4,     4,      -15,  -15,    4,     4,    -6,    RAND,
          RAND, 0,     0,     0,      0,     0,     0,     0,    0,     RAND,
          RAND, RAND,  RAND,  RAND,   RAND,  RAND,  RAND,  RAND, RAND,  RAND,
          RAND, RAND,  RAND,  RAND,   RAND,  RAND,  RAND,  RAND, RAND,  RAND };
double __STARTPUNKTE[120] =
        { RAND, RAND, RAND,  RAND,   RAND,  RAND, RAND, RAND,  RAND,   RAND,
          RAND, RAND, RAND,  RAND,   RAND,  RAND, RAND, RAND,  RAND,   RAND,
          RAND, 0,    0,     0,      0,     0,    0,    0,     0,      RAND,
          RAND, -6,   4,     4,      -15,   -15,  4,    4,     -6,     RAND,
          RAND, -6,   4,     2,      5,     5,    2,    4,     -6,     RAND,
          RAND, -6,   4,     5,      16,    16,   5,    4,     -6,     RAND,
          RAND, -5,   4,     10,     20,    20,   10,   4,     -5,     RAND,
          RAND, 3,    12,    20,     28,    28,   20,   12,    3,      RAND,
          RAND, 8,    16,    24,     32,    32,   24,   16,    8,      RAND,
          RAND, 0,    0,     0,      0,     0,    0,    0,     0,      RAND,
          RAND, RAND, RAND,  RAND,   RAND,  RAND, RAND, RAND,  RAND,   RAND,
          RAND, RAND, RAND,  RAND,   RAND,  RAND, RAND, RAND,  RAND,   RAND };
double __STARTPUNKTEx2[120] = // Weiße Springer
        { RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,    RAND,  RAND,  RAND,
          RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,    RAND,  RAND,  RAND,
          RAND, -53,  -42,  -32,   -21,    -21,    -32,     -42,   -53,   RAND,
          RAND, -42,  -32,  -10,   0,      0,      -10,     -32,   -42,   RAND,
          RAND, -21,  -10,  0,     0,      0,      0,       -10,   -21,   RAND,
          RAND, -18,  0,    3,     21,     21,     3,        0,    -18,   RAND,
          RAND, -18,  0,    10,    21,     21,     10,       0,    -18,   RAND,
          RAND, -21,  5,    10,    16,     16,     10,       5,    -21,   RAND,
          RAND, -42,  -32,  -10,   0,      0,      -10,      -32,  -42,   RAND,
          RAND, -53,  -42,  -32,   -21,    -21,    -32,      -42,  -53,   RAND,
          RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,     RAND, RAND,  RAND,
          RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,     RAND, RAND,  RAND };

double __STARTPUNKTEx3[120] =
        { RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,     RAND, RAND, RAND,
          RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,     RAND, RAND, RAND,
          RAND, -53,  -42,  -32,   -21,    -21,    -32,      -42,  -53,  RAND,
          RAND, -42,  -32,  -10,   0,      0,      -10,      -32,  -42,  RAND,
          RAND, -21,  5,    10,    16,     16,     10,       5,    -21,  RAND,
          RAND, -18,  0,    10,    21,     21,     10,       0,    -18,  RAND,
          RAND, -18,  0,    3,     21,     21,     3,        0,    -18,  RAND,
          RAND, -21,  -10,  0,     0,      0,      0,        -10,  -21,  RAND,
          RAND, -42,  -32,  -10,   0,      0,      -10,      -32,  -42,  RAND,
          RAND, -53,  -42,  -32,   -21,    -21,    -32,      -42,  -53,  RAND,
          RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,     RAND, RAND, RAND,
          RAND, RAND, RAND, RAND,  RAND,   RAND,   RAND,     RAND, RAND, RAND };
/*double __STARTPUNKTEx4[120] = //Wei√üe L√§ufer
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,-5, -5, -7, -5, -5, -7, -5, -5,	RAND,
RAND,0,  4,  2,  2,  2,  2,  4,  0,RAND,
RAND,0,  3,  4,  4,  4,  4,  3,  0,RAND,
RAND,0,  2,  4,  4,  4,  4,  2,  0,RAND,
RAND,0,  2,  4,  4,  4,  4,  2,  0,RAND,
RAND,0,  2,  4,  4,  4,  4,  2,  0,RAND,
RAND,0,  4,  2,  2,  2,  2,  4,  0,RAND,
RAND,	0,  0,  0,  0,  0,  0,  0,  0,RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};
double __STARTPUNKTEx5[120] =
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	0,  0,  0,  0,  0,  0,  0,  0,RAND,
RAND,0,  4,  2,  2,  2,  2,  4,  0,RAND,
RAND,0,  2,  4,  4,  4,  4,  2,  0,RAND,
RAND,0,  2,  4,  4,  4,  4,  2,  0,RAND,
RAND,0,  2,  4,  4,  4,  4,  2,  0,RAND,
RAND,0,  3,  4,  4,  4,  4,  3,  0,RAND,
RAND,0,  4,  2,  2,  2,  2,  4,  0,RAND,
RAND,-5, -5, -7, -5, -5, -7, -5, -5,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};
/*double __STARTPUNKTEx6[120] = //T√ºrme
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	0,  3,  5,  5,  5,  5,  3,  0,		RAND,
RAND,	-3,  2,  5,  5,  5,  5,  2, -3,RAND,
RAND,	-2,  0,  0,  2,  2,  0,  0, -2,RAND,
RAND,	-2,  0,  0,  0,  0,  0,  0, -2,RAND,
RAND,	0,  0,  0,  0,  0,  0,  0,  0,RAND,
RAND,	0,  0,  0,  0,  0,  0,  0,  0,RAND,
RAND,	22, 27, 27, 27, 27, 27, 27, 22,RAND,
RAND,	8, 11, 13, 13, 13, 13, 11,  8,RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};
double __STARTPUNKTEx7[120] =
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	8, 11, 13, 13, 13, 13, 11,  8,RAND,
RAND,	22, 27, 27, 27, 27, 27, 27, 22,RAND,
RAND,	0,  0,  0,  0,  0,  0,  0,  0,RAND,
RAND,	0,  0,  0,  0,  0,  0,  0,  0,RAND,
RAND,	-2,  0,  0,  0,  0,  0,  0, -2,RAND,
RAND,	-2,  0,  0,  2,  2,  0,  0, -2,RAND,
RAND,	-3,  2,  5,  5,  5,  5,  2, -3,RAND,
RAND,	0,  3,  5,  5,  5,  5,  3,  0,		RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};
double __STARTPUNKTEx8[120] = //Dame
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,-10, -5,  0,  0,  0,  0, -5,-10,	RAND,
RAND,-5,  0,  5,  5,  5,  5,  0, -5,RAND,
RAND,0,  5,  5,  6,  6,  5,  5,  0,RAND,
RAND,0,  5,  6,  6,  6,  6,  5,  0,RAND,
RAND,0,  5,  6,  6,  6,  6,  5,  0,RAND,
RAND, 0,  5,  5,  6,  6,  5,  5,  0,RAND,
RAND,-5,  0,  5,  5,  5,  5,  0, -5,RAND,
RAND,10, -5,  0,  0,  0,  0, -5,-10,RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};
double __STARTPUNKTEx9[120] =
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,10, -5,  0,  0,  0,  0, -5,-10,RAND,
RAND,-5,  0,  5,  5,  5,  5,  0, -5,RAND,
RAND, 0,  5,  5,  6,  6,  5,  5,  0,RAND,
RAND,0,  5,  6,  6,  6,  6,  5,  0,RAND,
RAND,0,  5,  6,  6,  6,  6,  5,  0,RAND,
RAND,0,  5,  5,  6,  6,  5,  5,  0,RAND,
RAND,-5,  0,  5,  5,  5,  5,  0, -5,RAND,
RAND,-10, -5,  0,  0,  0,  0, -5,-10,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};
double __STARTPUNKTEx10[120] = //K√∂nig
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	24, 24,  9,  0,  0,  9, 24, 24,		RAND,
RAND,	16, 14,  7, -3, -3,  7, 14, 16,RAND,
RAND,	4, -2, -5,-15,-15, -5, -2,  4,RAND,
RAND,	-10,-15,-20,-25,-25,-20,-15,-10,RAND,
RAND,	-15,-30,-35,-40,-40,-35,-30,-15,RAND,
RAND,	 -25,-35,-40,-45,-45,-40,-35,-25,RAND,
RAND,	-22,-35,-40,-40,-40,-40,-35,-22,RAND,
RAND,	-22,-35,-40,-40,-40,-40,-35,-22,RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};
double __STARTPUNKTEx11[120] =
{RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	-22,-35,-40,-40,-40,-40,-35,-22,RAND,
RAND,	-22,-35,-40,-40,-40,-40,-35,-22,RAND,
RAND,	 -25,-35,-40,-45,-45,-40,-35,-25,RAND,
RAND,	-15,-30,-35,-40,-40,-35,-30,-15,RAND,
RAND,	-10,-15,-20,-25,-25,-20,-15,-10,RAND,
RAND,	4, -2, -5,-15,-15, -5, -2,  4,RAND,
RAND,	16, 14,  7, -3, -3,  7, 14, 16,RAND,
RAND,	24, 24,  9,  0,  0,  9, 24, 24,		RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,
RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND};*/

double materialwert[15] = // Materialwert
        {
                0,                      // NIL! 0
                100,                    // Startbauer 1
                500,                    // durchgestarteter Startbauer 2
                33.3,                  // en passant Bauer 3
                2250,                   // Superbauer 4
                20,                     // Bauer 5
                66.666666666667,        // Pferd 6
                57.142857,              // Läufer 7
                75,                     // Turm 8
                133.3333333,            // Dame 9
                1000,                   // König 10
                909.0909091,            // Rochade König 11
                50,                     // Rochade Turm 12
        };


// Zahlen fuer den Zuggenerator, Sprenklereinstellungen
int bewegung[15][15] = // Anzahl, Richtung, Weite, wohin[richtung]
        {
                { 0, 0, 0   },       // -- unsinn, ignorieren --
                { 0, 1, 10  },       // Bauer vor seinem Start
                { 0, 0, 10  },       // durchgestarteter Startbauer (kann kein en passant)
                { 0, 0, 10  },       // en passant Bauer in Aktion, muss sich umverwandelungn
                { 0, 0, 0   },       // Umwandelungsbauer auf der anderen Grundlinie
                { 0, 0, 10  },       // Bauer
                { 7, 0, 21, 12, 19, 8, -21, -12, -19, -8}, // Pferd
                { 3, 6, 9, 11, -9, -11},             // Laeufer
                { 3, 6, 10, 1, -1, -10},             // Turm
                { 7, 6, 9, 10, 11, 1, -1, -9, -10, -11}, // Dame
                { 7, 0, 9, 10, 11, 1, -1, -9, -10, -11}, // Koenig vor Rochade
                { 7, 0, 9, 10, 11, 1, -1, -9, -10, -11}, // Koenig
                { 3, 6, 10, 1, -1, -10},             // Turm vor Rochade
                { 1, 0, 9, 11},                      // Bauer nach seinem Start
        };


// VARIABLEN
int zug_nummer;
denkpaar aktueller_zug[ende];
denkpaar bester_zug[ende];
int __FELD[ende + 2][120];
int Feld[ende + 2][200];
denkpaar zugstapel[ende + 2][200];
denkpaar best_one[ende + 2];
int sort_schema[ende][200];
denkpaar sort_schema_bewertung[ende][200];
int bewertet;               // MaÔ¨Ç f¬∏r die Partieeinheit
int timeline;               // Entscheidung Endspiel oder ErÀÜffnung, Einfluss
// auf Bewertung und Suchtiefe
spiel_status partie_status; // Ereoffnung, Mittelspiel....
double				  kingzone_ich[120];
double				  kingzone_gegner[120];
// double					OpenLines[8] =
// {1,1,1,1,1,1,1,1};

// FUNKTIONEN
void disp(int feld[120], int form = 0)  {
    cout << "\n";
    int breite = 3;

    cout << "      " << "  >--A--v--B--v--C--v--D--v--E--v--F--v--G--v--H--<\n";
    cout << "      " << "v >-----+-----+-----+-----+-----+-----+-----+-----< v\n" <<
         "      ";

    for (int j = 9; j > 1; j--)  {
        cout << j - 1;

        for (int i = 1; i < 9; i++)  {
            if (feld[j * 10 + i] != RAND)
                switch (form)   {
                    case 0: { cout << setw(breite) << " | " << setw(breite) <<
                                   figuren_char[feld[j * 10 + i] + figurenanzahl]; break; }

                    case 1: { cout << setw(breite) << " | " << setw(breite) <<
                                   feld[j * 10 + i]; break; }
                }
        }
        cout << setw(breite) << "| " << j - 1 << "\n" << "      " <<
             "^ >-----+-----+-----+-----+-----+-----+-----+-----< ^\n" << "      ";
    }
    cout << "  >--A--+--B--+--C--+--D--+--E--+--F--+--G--+--H--<  \n";
    cout << "\n";
}

void print_zugstapel(int n, denkpaar zugstapel[200])  {
    for (int i = 0; i < n; i++)  {
        cout << figuren_char[zugstapel[i].figur  + figurenanzahl] << ": "
             << int(zugstapel[i].z.pos.pos1) << "(" <<
             grundfeld_bezeichnungen[zugstapel[i].z.pos.pos1] << ")  => "
             << int(zugstapel[i].z.pos.pos2) << "(" <<
             grundfeld_bezeichnungen[zugstapel[i].z.pos.pos2] << ")";

        if (zugstapel[i].nw) {
            cout << " | ";
            int max = zugstapel[i].nw;

            for (int j = 0; j < max; j++)    {
                cout << int(zugstapel[i].verwandelung[j].pos1) << "(" <<
                     grundfeld_bezeichnungen[zugstapel[i].verwandelung[j].pos1] << ")  <= "
                     << figuren_char[zugstapel[i].verwandelung[j].fig  + figurenanzahl];

                if (j < max - 1) cout << ", ";
            }
        }

        cout << "\n";
    }
}

void disp_cleanest(int feld[120])  {
    cout << "\n";

    for (int j = 9; j > 1; j--)  {
        for (int i = 1; i < 9; i++)  {
            if (feld[j * 10 + i] !=
                RAND) cout << figuren_char[feld[j * 10 + i] + figurenanzahl];

            if (j * 10 + i != 28) cout << ",";
        }
        cout << "\n";
    }
    cout << "\n";
}

void writ(int feld[120], int form = 0)  {
    ofstream partie("partie.txt", ios::app);

    partie << "\n{\n";
    partie << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,\n"
           << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,\n";

    for (int j = 2; j < 10; j++)  {
        partie << "RAND, ";

        for (int i = 1; i < 9; i++)  {
            if (feld[j * 10 + i] != RAND)
                switch (form)   {
                    case 0: { partie << setw(6) <<
                                     figuren_intern[feld[j * 10 + i] + figurenanzahl]
                                     << ", "; break; }
                }
        }
        partie << "  RAND,";
        partie << "\n";
    }
    partie << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,\n"
           << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND\n";
    partie << "};";
    partie << "\n";
    partie.close();
}

struct endofinput : public exception {
    const char* what() const throw() {
        return "end of file in input stream!";
    }
};

int eingabe()  {
    bool okay = false;
    int  i, j;

    do {
        cout << "Feld ('.' fuer 'zieh doch selber!'):";
        char buchstabe;
        cin >> buchstabe;

        if (buchstabe == '.') return 666;

        char zahl;
        cin >> zahl;

        if (zahl == '.') return 666;

        if ((buchstabe == 'x') && (zahl == 'x')) { cout << "\n"; return false; }

        for (i = 0; i <= 7; i++)
            if ((buchstabe == buchstaben1[i]) || (buchstabe == buchstaben2[i]))
                for (j = 0; j <= 7; j++) {
                    if (zahl == zahlen[j]) {
                        okay = true;
                        return 21 + j * 10 + i;
                    }
                }

        if (cin.eof()) throw endofinput();
    } while (!okay);
    return 0;
}

void zuege_append(vector<string>& zuege, string _hash)  {
    zuege.insert(zuege.end(), (_hash));
}

bool zuege_wied(vector<string>& _zuege)  {
    // outputs a list of uniqe words
    set<string> unique(_zuege.begin(), _zuege.end());

    // for (auto element : unique)
    //	cout << element << ' ' << count(_zuege.begin(), _zuege.end(), element)
    // << endl;

    std::map<std::string, int> count;

    for (auto x : _zuege) ++count[x];

    int  val = 2;
    auto it  = std::find_if(count.begin(), count.end(),
                            [val](const std::pair<std::string, int>& t) -> bool {
                                return t.second > val;
                            }
    );

    if (it == count.end())  {
        return false;
    }
    else {
        cout << "position id " << (it->first)
             << "after moves ";

        int ii = 0;

        for  (auto y : _zuege)  {
            ii += 1;

            if (y == (it->first)) cout << (double)ii / 2 << " ";
        }


        return true;
    }
}


class Spielfeld  {

public:

    int         zuggenerator();
    inline void add_zug(const int & pos1,
                        const int & pos2,
                        const int & n,
                        const bool& _kill,
                        const int & _figur);
    inline void add_verwandelung(const int& farbe,
                                 const int& pos,
                                 const int& was,
                                 const int& n);
    inline bool      test_drohung(int feld[],
                                  int farbe,
                                  int pos);
    inline howitends check_end(vector<string>& _zuege);
    inline howitends last_moves();

    int n;
    int nn;
    bool Z;
    int Stufe;
    int Farbe;
    int spezial;
    int wking = 99;
    int bking = 99;
    int test = 0;

    Spielfeld();
    Spielfeld(int _feld[120],
              int _farbe,
              int _stufe);
    void      zug_reset();

    // Spielfeld (Spielfeld & spiel);
    feldtyp * to_feldtyp(feldtyp *neues);
    feldtyp * to_feldtyp();
    int     * to_feld(int _feld[120]);
    int     * to_feld();
    void      copy(Spielfeld& _spiel);

    void      setFarbe(int _farbe);

    int       getStufe();
    void      setStufe(int i);

    bool      look_richtung_td(const int feld [], const int &farbe, const int &pos, const int &step);
    bool      look_richtung_ld(const int feld [], const int &farbe, const int &pos, const int &step);

    void find_kings();

    void      setPos(int _feld[120],
                     int _farbe,
                     int _stufe,
                     vector<string>& _zuege);
    string    hash();

    void      disp();
    void      disp_cleanest();
    void      write();
    void      print_zugstapel();
    denkpaar* makeZugstapel();

    void zug(denkpaar&);
    void realer_zug(denkpaar&, vector<string>& _zuege);

    void norm_zug(denkpaar&);

    bool schach(int _farbe);
};


howitends Spielfeld::check_end(vector<string>& _zuege)  {
    find_kings();
    //print_zugstapel();
    //cout << "STUFE::: "<< this ->getStufe() << " w king: "<< this->wking << " b king: " << this->bking;

    if (this -> wking == 0 || this -> bking == 0)  {
        //disp();
        cout << "He took the king!\n";
        //  test = 1;
        return schachmatt;
    }

    if (this->test_drohung(Feld[this->getStufe()], 1, this->wking))  {
        //cout << "weiss hat schach/n";
        if (Farbe > 0)  {
            //return matt;        // verloren
        }
        else {/*test = 1;*/ return schachmatt;}
    }

    if (this->test_drohung(Feld[this->getStufe()], -1, this->bking))  {
        //cout << "schwarz hat schach/n";
        if (Farbe < 0)  {
            //return matt;        // verloren
        }
        else {/*test = 1;*/ return schachmatt;}
    }



    if (bester_zug[0].z.pos.pos1 == 0 && bester_zug[0].z.pos.pos2 == 0)  {
        if (Farbe > 0)  {

            if (this->test_drohung(Feld[this->getStufe()], this->Farbe,
                                   this->wking)) {/*test = 1;*/ return matt;}       // verloren

            if (this->test_drohung(Feld[this->getStufe()], this->Farbe * -1,
                                   this->bking)) {/*test = 1;*/ return schachmatt;}  // gewonnen
        }


        if (Farbe < 0)  {
            if (this->test_drohung(Feld[this->getStufe()], this->Farbe * -1,
                                   this->wking)) {/*test = 1;*/ return schachmatt;}  // gewonnen

            if (this->test_drohung(Feld[this->getStufe()], this->Farbe,
                                   this->bking)) {/*test = 1;*/ return matt;}        // verloren
        }
        return patt;                                               // kein zug
    }                                                           // moeglich  (was
    // ist mit remis
    // bei
    // gefesselten

    if (zuege_wied(_zuege)) return remis;
    else return nothing;
}

int gegner;
howitends Spielfeld::last_moves()  {
    // testet, ob, nachdem der Zug gesetzt wurde, noch Schach ist; wenn der
    // Gegner nach seinem Zug noch im Schach steht,
    // hat er einen falschen gemacht
    gegner = this->Farbe;

    find_kings();

    if (Farbe  < 0)  {
        if (this->test_drohung(Feld[this->getStufe()], 1, this->wking))  {
            //cout << "weiss hat schach";

            /* test =1;*/
            return schaach; // verloren
        }
    }

    if (Farbe > 0)  {
        if (this->test_drohung(Feld[this->getStufe()], -1, this->bking))  {
            //cout << "schwarz hat schach";
            /*test = 1;*/
            return schaach;
        }
    }
    return nothing;
}

Spielfeld::Spielfeld()  {
    Farbe = 0;
    Stufe = 0;
    { for (int i = 0; i < 120; i++)  {
            Feld[Stufe][i] = 0;
        } }
}

Spielfeld::Spielfeld(int _feld[120], int _farbe = 0, int _stufe = 0)  {
    setFarbe(_farbe);
    setStufe(_stufe);
    { for (int i = 0; i < 120; i++)  {
            Feld[Stufe][i] = _feld[i];
        } }
}

string int_array_to_string(int int_array[], int size_of_array) {
    ostringstream oss("");

    for (int temp = 0; temp < size_of_array; temp++) oss << int_array[temp];
    return oss.str();
}

string Spielfeld::hash()  {
    Feld[1][0] = Farbe;
    string str = int_array_to_string(Feld[1], 120);
    Feld[1][0] = RAND;
    string str2 = int_array_to_string(Feld[1], 120);

    std::size_t str_hash = std::hash<std::string>{} (str) +
                                                 std::hash<std::string>{} (str2);

    // std::cout << "hash(" << std::quoted(str) << ") = " << str_hash << '\n';

    return to_string(str_hash);
}

inline void Spielfeld::zug_reset()  {
    Stufe = 0;

    for (int i = 0; i < 120; i++)  {
        Feld[Stufe][i] = Feld[Stufe + 1][i];
    }

    for (int j = 0; j < ende; j++)  {
        bester_zug[j].z.pos.pos1 = 0;
        bester_zug[j].z.pos.pos2 = 0;
    }
}

feldtyp * Spielfeld::to_feldtyp(feldtyp *neues) {
    { for (int i = 0; i < 120; i++)  {
            neues->feld[i] = Feld[Stufe][i];
        } }
    return neues;
}

feldtyp * Spielfeld::to_feldtyp() {
    feldtyp *neues = new feldtyp;
    { for (int i = 0; i < 120; i++)  {
            neues->feld[i] = Feld[Stufe][i];
        } }

    return neues;
}

inline int * Spielfeld::to_feld(int _feld[120])  {
    { for (int i = 0; i < 120; i++)  {
            _feld[i] = Feld[Stufe][i];
        } }
    return _feld;
}

inline int * Spielfeld::to_feld()  {
    int *_feld = new int [120];
    { for (int i = 0; i < 120; i++)  {
            _feld[i] = Feld[Stufe][i];
        } }

    return _feld;
}

inline void Spielfeld::copy(Spielfeld& _spiel)  {
    Farbe = _spiel.Farbe;
    Stufe = _spiel.Stufe;
}

inline void Spielfeld::setPos(int _feld[], int _farbe, int _stufe, vector<string> & _zuege) {
    setFarbe(_farbe);
    setStufe(_stufe);
    { for (int i = 0; i < 120; i++)  {
            Feld[Stufe][i] = _feld[i];
        } }
    _zuege.clear();
    return;

}

inline void Spielfeld::setFarbe(int _farbe)  {
    Farbe = _farbe;
}

inline void Spielfeld::setStufe(int _stufe)  {
    Stufe = _stufe;
}

inline int Spielfeld::getStufe()  {
    return Stufe;
}

inline void Spielfeld::zug(denkpaar& _zug)  {
    setStufe(Stufe + 1);

    for (int i = 0; i < 120; i++)  {
        Feld[Stufe][i] = Feld[Stufe - 1][i];
    }

    Feld[Stufe][_zug.z.pos.pos2] = Feld[Stufe][_zug.z.pos.pos1];
    Feld[Stufe][_zug.z.pos.pos1] = LEER;

    if ((_zug.nw)) {
        int max = _zug.nw;

        for (int j = 0; j < max; j++)    {
            Feld[Stufe][_zug.verwandelung[j].pos1] = _zug.verwandelung[j].fig;
        }
    }

    setFarbe(Farbe * -1);

    Z = false;
}

inline void Spielfeld::norm_zug(denkpaar& _zug)  {
    Feld[0][_zug.z.pos.pos2] = Feld[Stufe][_zug.z.pos.pos1];
    Feld[0][_zug.z.pos.pos1] = LEER;

    if ((_zug.nw)) {
        int max = _zug.nw;

        for (int j = 0; j < max; j++)    {
            Feld[0][_zug.verwandelung[j].pos1] = _zug.verwandelung[j].fig;
        }
    }
    setFarbe(Farbe * -1);
    Z = false;


}

inline void Spielfeld::realer_zug(denkpaar& _zug, vector<string>& _zuege)  {
    zug (_zug);
    zuege_append(_zuege, this->hash());
    return;
}

inline void Spielfeld::add_zug(const int & pos1,
                               const int & pos2,
                               const int & _n,
                               const bool& _kill,
                               const int & _figur)  {



    zugstapel[Stufe][_n].z.pos.pos1 = pos1;
    zugstapel[Stufe][_n].z.pos.pos2 = pos2;
    zugstapel[Stufe][_n].kill       = _kill;
    zugstapel[Stufe][_n].figur      = _figur;
    n++;
    return;
}

inline void Spielfeld::add_verwandelung(const int& farbe,
                                        const int& pos,
                                        const int& was,
                                        const int& n) {
    zugstapel[Stufe][n].verwandelung[zugstapel[Stufe][n].nw].pos1 = pos;
    zugstapel[Stufe][n].verwandelung[zugstapel[Stufe][n].nw].fig  = was * farbe;
    zugstapel[Stufe][n].nw++;
}

inline bool Spielfeld::look_richtung_td(const int feld[], const int &farbe, const int &pos, const int &step)  {
    int zielfeld, farbvorzeichen, i;
    for (i = pos + step; 19 < i && i < 100; i += step)  {
        zielfeld = feld[i];
        if (zielfeld == RAND) break;
        if (zielfeld == LEER) continue;

        farbvorzeichen = abs(zielfeld) / zielfeld;

        if (farbvorzeichen == farbe) break;

        if ((zielfeld == W_D * farbe * -1) ||
            (zielfeld == W_T * farbe * -1) || (zielfeld == W_Tr * farbe * -1))
            return true;
        else break;
    }
    return false;
}

inline bool Spielfeld::look_richtung_ld(const int feld[], const int &farbe, const int &pos, const int &step)  {
    int zielfeld, farbvorzeichen, i;
    for (i = pos + step; 19 < i && i < 100; i += step)  {
        zielfeld = feld[i];
        if (zielfeld == RAND) break;
        if (zielfeld == LEER) continue;

        farbvorzeichen = abs(zielfeld) / zielfeld;

        if (farbvorzeichen == farbe) break;

        if ((zielfeld == W_D * farbe * -1) ||
            (zielfeld == W_L * farbe * -1) )
            return true;
        else break;
    }
    return false;
}

inline bool Spielfeld::test_drohung(int feld[], int farbe, int pos)  {
    if ((pos < 0) || (pos > 99)) {
        cout << pos << " ";
        return false;
    }

    return look_richtung_td(feld, farbe, pos, 10) ||
           look_richtung_td(feld, farbe, pos, -10) ||
           look_richtung_td(feld, farbe, pos,  1) ||
           look_richtung_td(feld, farbe, pos, -1) ||
           look_richtung_ld(feld, farbe, pos,  9) ||
           look_richtung_ld(feld, farbe, pos,  -9) ||
           look_richtung_ld(feld, farbe, pos, 11) ||
           look_richtung_ld(feld, farbe, pos, -11) ||

           (feld[pos + 21 * farbe] == W_P * farbe * -1) ||
           (feld[pos + 12 * farbe] == W_P * farbe * -1) ||
           (feld[pos + 19 * farbe] == W_P * farbe * -1) ||
           (feld[pos + 8  * farbe] == W_P * farbe * -1) ||
           (feld[pos + 9  * farbe] == W_B * farbe * -1) ||
           (feld[pos + 11 * farbe] == W_B * farbe * -1) ||

           (feld[pos + 11 * farbe] == W_K * farbe * -1 ||
            feld[pos + -11 * farbe] == W_K * farbe * -1 ||
            feld[pos + 1 * farbe] == W_K * farbe * -1 ||
            feld[pos + -1 * farbe] == W_K * farbe * -1 ||
            feld[pos + 10 * farbe] == W_K * farbe * -1 ||
            feld[pos + -10 * farbe] == W_K * farbe * -1 ||
            feld[pos + 9 * farbe] == W_K * farbe * -1 ||
            feld[pos + -9 * farbe] == W_K * farbe * -1 );
}

inline void Spielfeld::find_kings()  {
    // setzt wking und bking auf entsprechende Werte

    wking = 0;
    bking = 0;
    int farbvorzeichen;
    int figur;

    for (int i = 21; i <= 98; i++) {

        figur = (abs(Feld[Stufe][i]));

        if ((figur == LEER) || (figur == RAND))
            continue;


        farbvorzeichen = figur / Feld[Stufe][i];

        if ((figur == W_K) || (figur == W_Kr)) {
            if (farbvorzeichen > 0)
                wking = i;
            else
                bking = i;
        }
    }
}

int Spielfeld::zuggenerator()  {
    int pos1, pos2;
    int enp_l, enp_r;
    int ziel, zielfeld;
    int farbvorzeichen, figur;



    int zugnr = 0;

    n = 0; // Variable der Klasse, wenn man es neu deklarieren wuerde,
    // kommt es zu einem seltsamen Fehler in der Zugsortierung,
    // weil n lokal dann 0 bleibt
    int en_passent_bauer = 0;
    spezial = NICHTS;
    test = 0;

    for (int o = 0; o < 199; o++) zugstapel[Stufe][o].nw = 0;

    for (int i = 21; i <= 98; i++) {
        figur = (abs(Feld[Stufe][i]));


        if ((figur == LEER) || (figur == RAND))

            continue;

        farbvorzeichen = figur / Feld[Stufe][i];


        pos1           = i;

        if (farbvorzeichen == Farbe)      {
            if ((figur == W_Bx) || (figur == W_B) || (figur == W_Bp_r) ||
                (figur == W_Bp_l))        {
                // Bauernschlag fuer Startbauer, normalen Bauern, en passant-Bauer
                if ((figur == W_Bp_r) || (figur == W_Bp_l))  {
                    // en passant bauer, der nicht gezogen wird, kann spaeter nicht mehr
                    en_passent_bauer = pos1;
                }




                ziel = pos2 = pos1 + farbvorzeichen * 9;

                // links vor und schlagen
                zielfeld = Feld[Stufe][ziel];

                if  (figur == W_Bp_l)  {
                    add_verwandelung(farbvorzeichen, pos2 - 10 * farbvorzeichen, LEER, n);
                    add_verwandelung(farbvorzeichen, pos2,      W_B,  n);
                    add_zug(pos1, pos2, n, true, figur);
                }


                if (zielfeld != RAND)   {
                    if (zielfeld != LEER)   {
                        // schraeg schlagen
                        if (zielfeld == -1 * W_K * farbvorzeichen || zielfeld == -1 * W_Kr * farbvorzeichen)      {
                            spezial = SCHACH; /*test = 1;*/
                            return 0;
                        }



                        if (zielfeld / abs(zielfeld) != farbvorzeichen)   {
                            spezial = UNRUH;

                            if (figur == W_Bx) {
                                add_verwandelung(farbvorzeichen, pos2, W_B, n);
                            } else
                            if (figur == W_B)  { // Bauernumwandelung per schlag
                                if (Farbe > 0)  {
                                    if ((91 <= pos2) && (pos2 <= 98))  {
                                        add_verwandelung(farbvorzeichen, pos2, W_D, n);
                                        add_zug(pos1, pos2, n, true, W_D);
                                        add_verwandelung(farbvorzeichen, pos2, W_P, n);
                                        add_zug(pos1, pos2, n, true, W_P);

                                        //		break;
                                    }
                                } else
                                if (Farbe < 0)  {
                                    if ((21 <= pos2) && (pos2 <= 28))  {
                                        add_verwandelung(farbvorzeichen, pos2, W_D, n);
                                        add_zug(pos1, pos2, n, true, W_D);
                                        add_verwandelung(farbvorzeichen, pos2, W_P, n);
                                        add_zug(pos1, pos2, n, true, W_P);

                                        //		break;
                                    }
                                }
                            }
                            add_zug(pos1, pos2, n, true, figur);
                        }
                    }
                }

                // rechts vor
                pos2     = ziel = pos1 + farbvorzeichen * 11;
                zielfeld = Feld[Stufe][ziel];

                if  (figur == W_Bp_r)  {
                    add_verwandelung(farbvorzeichen, pos2 - 10 * farbvorzeichen, LEER, n);
                    add_verwandelung(farbvorzeichen, pos2,      W_B,  n);
                    add_zug(pos1, pos2, n, true, figur);
                } else

                if (((zielfeld = Feld[Stufe][ziel]) != RAND))   {
                    if (zielfeld != LEER)   { // schraeg schlagen
                        if (zielfeld == -1 * W_K * farbvorzeichen)      {
                            spezial = SCHACH; /*test = 1;*/
                            return 0;
                        }

                        if (zielfeld / abs(zielfeld) != farbvorzeichen)   {
                            spezial = UNRUH;

                            if (figur == W_Bx) add_verwandelung(farbvorzeichen, pos2, W_B, n);
                            else
                            if (figur == W_B)  { // Bauernumwandelung per schlag
                                if (Farbe > 0)  {
                                    if ((91 <= pos2) && (pos2 <= 98))  {
                                        add_verwandelung(farbvorzeichen, pos2, W_D, n);
                                        add_zug(pos1, pos2, n, true, figur);
                                        add_verwandelung(farbvorzeichen, pos2, W_P, n);
                                        add_zug(pos1, pos2, n, true, figur);

                                        //		break;
                                    }
                                } else
                                if (Farbe < 0)  {
                                    if ((21 <= pos2) && (pos2 <= 28))  {
                                        add_verwandelung(farbvorzeichen, pos2, W_D, n);
                                        add_zug(pos1, pos2, n, true, figur);
                                        add_verwandelung(farbvorzeichen, pos2, W_P, n);
                                        add_zug(pos1, pos2, n, true, figur);

                                        //		break;
                                    }
                                }
                            }
                            add_zug(pos1, pos2, n, true, figur);
                        }
                    }
                }
            } //Bauer endet hier

            // andere figuren
            for (int richtung = 0; richtung <= bewegung[figur][0]; richtung++)  {
                for (int weite = 0; weite <= bewegung[figur][1]; weite++)  {
                    pos2 =  pos1 + farbvorzeichen * bewegung[figur][2 + richtung] *
                                   (weite + 1);
                    int zielfeld = Feld[Stufe][pos2];

                    // schlagen
                    if (zielfeld != LEER)  {
                        int zielfigur = abs(zielfeld);

                        if (zielfeld == RAND)                       // Aus!
                            break;

                        if (zielfeld / zielfigur == farbvorzeichen) // eigene Figur
                            break;

                        if      ((figur == W_Bx) || (figur == W_Bp_l) || (figur  == W_B) ||
                                 (figur == W_Bp_r)) // kein Bauer schlaegt geradeaus
                            break;



                        if ((zielfeld == -1 * W_K * farbvorzeichen) ||
                            (zielfeld == -1 * W_Kr * farbvorzeichen))        {
                            spezial = SCHACH; /*test = 1;*/

                            return 0;
                        }



                        if ((figur == W_Kr) || (figur == W_K)) {
                            if (test_drohung(Feld[Stufe], Farbe, pos1)) {
                                test = 1;

                            }
                            if (test_drohung(Feld[Stufe], Farbe, pos2))  {
                                test = 1;
                                break;
                            }
                        }

                        if (figur == W_Kr) {
                            add_verwandelung(farbvorzeichen, pos2, W_K, n);
                        } else
                        if (figur == W_Tr) {
                            add_verwandelung(farbvorzeichen, pos2, W_T, n);
                        }



                        spezial = UNRUH;
                        add_zug(pos1, pos2, n, true, figur);

                        break;
                    }

                    // gehen
                    if (figur == W_B)  { // Bauernumwandelung
                        if (Farbe > 0)  {
                            if ((91 <= pos2) && (pos2 <= 98))  {
                                add_verwandelung(farbvorzeichen, pos2, W_D, n);
                                add_zug(pos1, pos2, n, false, figur);
                                add_verwandelung(farbvorzeichen, pos2, W_P, n);
                                add_zug(pos1, pos2, n, false, figur);

                                //		break;
                            }
                        } else
                        if (Farbe < 0)  {
                            if ((21 <= pos2) && (pos2 <= 28))  {
                                add_verwandelung(farbvorzeichen, pos2, W_D, n);
                                add_zug(pos1, pos2, n, false, figur);
                                add_verwandelung(farbvorzeichen, pos2, W_P, n);
                                add_zug(pos1, pos2, n, false, figur);

                                //		break;
                            }
                        }
                    } else

                    if ((figur == W_Bp_r) || (figur == W_Bp_l)) add_verwandelung(
                                farbvorzeichen,
                                pos2,
                                W_B,
                                n);
                    else
                    if (figur == W_Bx) {
                        add_verwandelung(farbvorzeichen, pos2, W_B, n);

                        if (weite == 1)  {
                            enp_r = Feld[Stufe][pos2 + farbvorzeichen];
                            enp_l = Feld[Stufe][pos2 - farbvorzeichen];

                            if (enp_r == -1 * W_B * farbvorzeichen)  {
                                add_verwandelung(farbvorzeichen * -1,
                                                 pos2 + farbvorzeichen,
                                                 W_Bp_r,
                                                 n);
                            }

                            if (enp_l == -1 * W_B * farbvorzeichen)  {
                                add_verwandelung(farbvorzeichen * -1,
                                                 pos2 - farbvorzeichen,
                                                 W_Bp_l,
                                                 n);
                            }
                        }
                    }

                    if ((figur == W_Kr) || (figur == W_K) ) {
                        if (test_drohung(Feld[Stufe], Farbe, pos1)) {
                            test = 1;

                        }
                        if (test_drohung(Feld[Stufe], Farbe, pos2))  {
                            //    test = 1;
                            break;
                        }

                    }

                    if (figur == W_Kr) {
                        add_verwandelung(farbvorzeichen, pos2, W_K, n);
                    } else
                    if (figur == W_Tr) {
                        add_verwandelung(farbvorzeichen, pos2, W_T, n);
                    }



                    add_zug(pos1, pos2, n, false, figur);
                }
            }
        }
    }

    // Rochade

    if ((Feld[Stufe][25] == W_Kr) || (Feld[Stufe][95] == S_Kr))  {
        if (Farbe < 0) {
            if ((Feld[Stufe][95] == S_Kr) && (Feld[Stufe][96] == LEER) &&
                (Feld[Stufe][97] == LEER) && (Feld[Stufe][98] == S_Tr))  {
                if (!test_drohung(Feld[Stufe], Farbe,
                                  95) &&
                    !test_drohung(Feld[Stufe], Farbe,
                                  96) && !test_drohung(Feld[Stufe], Farbe, 97))  {
                    add_verwandelung(Farbe, 97, W_K,  n);
                    add_verwandelung(Farbe, 96, W_T,  n);
                    add_verwandelung(Farbe, 98, LEER, n);
                    add_zug(95, 97, n, false, figur);
                }
            }

            if ((Feld[Stufe][95] == S_Kr) && (Feld[Stufe][94] == LEER) &&
                (Feld[Stufe][93] == LEER) && (Feld[Stufe][92] == LEER) &&
                (Feld[Stufe][91] == S_Tr))  {
                if (!test_drohung(Feld[Stufe], Farbe,
                                  95) &&
                    !test_drohung(Feld[Stufe], Farbe,
                                  94) && !test_drohung(Feld[Stufe], Farbe, 93))  {
                    add_verwandelung(Farbe, 93, W_K,  n);
                    add_verwandelung(Farbe, 94, W_T,  n);
                    add_verwandelung(Farbe, 91, LEER, n);
                    add_zug(95, 93, n, false, figur);
                }
            }
        } else
        if (Farbe > 0) {
            if ((Feld[Stufe][25] == W_Kr) && (Feld[Stufe][26] == LEER) &&
                (Feld[Stufe][27] == LEER) && (Feld[Stufe][28] == W_Tr))  {
                if (!test_drohung(Feld[Stufe], Farbe,
                                  25) &&
                    !test_drohung(Feld[Stufe], Farbe,
                                  26) && !test_drohung(Feld[Stufe], Farbe, 27))  {
                    add_verwandelung(Farbe, 27, W_K,  n);
                    add_verwandelung(Farbe, 26, W_T,  n);
                    add_verwandelung(Farbe, 28, LEER, n);
                    add_zug(25, 27, n, false, figur);
                }
            }

            if ((Feld[Stufe][25] == W_Kr) && (Feld[Stufe][24] == LEER) &&
                (Feld[Stufe][23] == LEER) && (Feld[Stufe][22] == LEER) &&
                (Feld[Stufe][21] == W_Tr))  {
                if (!test_drohung(Feld[Stufe], Farbe,
                                  25) &&
                    !test_drohung(Feld[Stufe], Farbe,
                                  24) && !test_drohung(Feld[Stufe], Farbe, 23))  {
                    add_verwandelung(Farbe, 23, W_K,  n);
                    add_verwandelung(Farbe, 24, W_T,  n);
                    add_verwandelung(Farbe, 21, LEER, n);
                    add_zug(25, 23, n, false, figur);
                }
            }
        }
    }

    // wenn ein en passent bauer gefunden wurde, dann musser bei allen zuegen,
    // ausser bei seinen eigenen im naechsten zug umgewandelt werden
    if (en_passent_bauer != 0)  {
        int q;

        for (q = 0; q < n; q++)  {
            figur = zugstapel[Stufe][q].figur;

            if (!((figur  == W_Bp_l) || (figur  == W_Bp_r)))  {
                add_verwandelung(Farbe, en_passent_bauer, W_B, q);
            }
        }
    }
    return n;
}

inline denkpaar * Spielfeld::makeZugstapel()  {
    zuggenerator();
    Z = true;
    return zugstapel[Stufe];
}

int schach_bewegung[15][15] = // Richtung, Weite, wohin[richtung]
        {
                { 0, 0, 0   },              // NIL!
                { 7, 0, 21, -21, 12, -12, 19, -19, 8, -8},               // Pferd
                { 7, 6, 1, -1, 9, -9, 10, -10, 11, -11},              // Dame;
        };

inline bool Spielfeld::schach(int _farbe)  {
    /*	int pos1, pos2, figur, farbvorzeichen;


            for (int i=21; i<=98; i++ )	{  //König finden
                    figur= (abs(Feld[Stufe][i]));
                    if (figur == W_K || figur == W_Kr)  {
                            farbvorzeichen = figur/Feld[Stufe][pos1];
                            if (farbvorzeichen == _farbe)  {
                                    pos1 = i;
                                    break;
                                    }
                            }
                    }
            for (int schach_bewegung_figur = 1; schach_bewegung_figur <= 2;
               schach_bewegung_figur++)  {
                    for (int richtung = 0; richtung
                       <=schach_bewegung[schach_bewegung_figur][0]; richtung++)  {
                            for (int weite = 0; weite <=
                               schach_bewegung[schach_bewegung_figur][1]; weite++)
                                {
                                    pos2 =	pos1 + farbvorzeichen *
                                       schach_bewegung[schach_bewegung_figur][2+richtung]
                                       * (weite+1);
                                    int pos2_figur = Feld[Stufe][pos2];
                                    if (zielfeld != LEER)  {
                                            int zielfigur = abs(zielfeld);
                                            if (zielfeld == RAND) // über den
                                               Tellerrand schauen...
                                                    break;
                                            if (zielfeld/zielfigur ==
                                               farbvorzeichen)   // eigene Figur
                                                    break;
                                            if    ((figur == W_Bx) || (figur ==
                                               W_Bp_l) || (figur  == W_B) ||
                                               (figur == W_Bp_r))	// kein Bauer
                                               schlÃ¤gt geradeaus
                                                    break;
                                            return 0;
                                            }
                                            add_zug(pos1, pos2, n, true);
                                    break;
                                    }
                            add_zug(pos1, pos2, n);
                                    }
                            }
                    }
            return n;*/
    return 0;
}

void Spielfeld::disp()  {
    cout << "\n";
    int breite = 3;

    cout << "      " << "  >--A--v--B--v--C--v--D--v--E--v--F--v--G--v--H--<\n";
    cout << "      " << "v >-----+-----+-----+-----+-----+-----+-----+-----< v\n" <<
         "      ";

    for (int j = 9; j > 1; j--)  {
        cout << j - 1;

        for (int i = 1; i < 9; i++)  {
            if (Feld[Stufe][j * 10 + i] != RAND) cout << setw(breite) << " | " << setw(
                        breite) << figuren_char[Feld[Stufe][j * 10 + i] + figurenanzahl];
        }
        cout << setw(breite) << "| " << j - 1 << "\n" << "      " <<
             "^ >-----+-----+-----+-----+-----+-----+-----+-----< ^\n" << "      ";
    }
    cout << "  >--A--+--B--+--C--+--D--+--E--+--F--+--G--+--H--< ^\n";
    cout << "\n";
}

void Spielfeld::disp_cleanest()  {
    cout << "\n";

    for (int j = 9; j > 1; j--)  {
        for (int i = 1; i < 9; i++)  {
            if (Feld[Stufe][j * 10 + i] !=
                RAND) cout << figuren_char[Feld[Stufe][j * 10 + i] + figurenanzahl];

            if (j * 10 + i != 28) cout << ",";
        }
        cout << "\n";
    }
    cout << "\n";
}

void Spielfeld::print_zugstapel()  {
    for (int i = 0; i < n; i++)  {
        cout << figuren_char[zugstapel[Stufe][i].figur  + figurenanzahl] << ": "
             << int(zugstapel[Stufe][i].z.pos.pos1) << "(" <<
             grundfeld_bezeichnungen[zugstapel[Stufe][i].z.pos.pos1] << ")  => "
             << int(zugstapel[Stufe][i].z.pos.pos2) << "(" <<
             grundfeld_bezeichnungen[zugstapel[Stufe][i].z.pos.pos2] << ")";

        if (zugstapel[Stufe][i].nw) {
            cout << " | ";
            int max = zugstapel[Stufe][i].nw;

            for (int j = 0; j < max; j++)    {
                cout << int(zugstapel[Stufe][i].verwandelung[j].pos1)
                     << "(" <<
                     grundfeld_bezeichnungen[zugstapel[Stufe][i].verwandelung[j].pos1] <<
                     ")  <= "
                     << figuren_char[zugstapel[Stufe][i].verwandelung[j].fig  +
                                     figurenanzahl];

                if (j < max - 1) cout << ", ";
            }
        }

        cout << "\n";
    }
}

void Spielfeld::write()  {
    ofstream partie("partie.txt", ios::app);

    partie << "\n{\n";
    partie << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,\n"
           << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,\n";

    for (int j = 2; j < 10; j++)  {
        partie << "RAND, ";

        for (int i = 1; i < 9; i++)  {
            if (Feld[Stufe][j * 10 + i] != RAND)
                partie
                        << setw(6)
                        << figuren_intern[Feld[Stufe][j * 10 + i] + figurenanzahl]
                        << ", ";
        }
        partie << "  RAND,";
        partie << "\n";
    }
    partie << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,\n"
           << "RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND,	RAND\n";
    partie << "};";
    partie << "\n";
    partie.close();
}

inline double entwicklung(int feld[120], int farbe)    {
    double wertung = 0;
    int    dieses_feld;

    for (int i = 21; i <= 98; i++)  {
        //dieses_feld = feld[i];

        if (feld[i] == RAND || abs(feld[i])>6) continue;

        if (feld[i] == __STARTFELD[i]) wertung += 2* __STARTPUNKTE[i];        // -kingzone_ich[i]*10;	//4.1
        if (feld[i] == __STARTFELDx[i]) wertung -= 2 * __STARTPUNKTEx[i];                                    // -kingzone_gegner[i]*10;//-kingzone_ich[i]*10;	//4.1
        //	else wertung -= 1 * __STARTPUNKTEx[i];}//-kingzone_gegner[i]*10;*/
        if (feld[i] == __STARTFELDx2[i]) wertung +=  __STARTPUNKTEx2[i];  // +kingzone_ich[i]*10;	//1.17
        if (feld[i] == __STARTFELDx3[i]) wertung -=  __STARTPUNKTEx3[i];  // -kingzone_gegner[i]*10;
        //REST PSQ
/*    if (feld[i] == __STARTFELDx4[i]) wertung += 0.55* __STARTPUNKTEx4[i];  // +kingzone_ich[i]*10;	//1.17
    if (feld[i] == __STARTFELDx5[i]) wertung -=  0.55* __STARTPUNKTEx5[i];//*/
        /* if (feld[i] == __STARTFELDx6[i]) wertung +=  __STARTPUNKTEx6[i];  // +kingzone_ich[i]*10;	//1.17
          if (feld[i] == __STARTFELDx7[i]) wertung -=  __STARTPUNKTEx7[i];
          if (feld[i] == __STARTFELDx8[i]) wertung +=  __STARTPUNKTEx8[i];  // +kingzone_ich[i]*10;	//1.17
          if (feld[i] == __STARTFELDx9[i]) wertung -=  __STARTPUNKTEx9[i];
          if (feld[i] == __STARTFELDx10[i]) wertung +=  __STARTPUNKTEx10[i];  // +kingzone_ich[i]*10;	//1.17
          if (feld[i] == __STARTFELDx11[i]) wertung -=  __STARTPUNKTEx11[i];//*/

    }
    return wertung;
}

inline double material(int feld[120], int farbe)  {
    double wert = 0;
    int    figur;
    for(int j=21; j<99; ++j) {kingzone_gegner[j] = 0;kingzone_ich[j] = 0;}
    for (int i = 21; i <= 98; i++)     {
        figur = feld[i];

        if ((figur == RAND) || (figur == LEER)) continue;
        wert += figur * materialwert[abs(figur)];

        //	cout << OpenLines[3] << "\n";
        //		if (abs(figur)<6) {	OpenLines[i%10-1]=0;}

        //	cout << OpenLines[3] << "\n";

        /*if ((abs(figur) == W_K||abs(figur) == W_Kr) && (feld[i]/abs(figur)) != farbe)
           {kingzone_gegner[i] = 1;
           kingzone_gegner[i+1] = 1;
           kingzone_gegner[i-1] = 1;
           kingzone_gegner[i-9] = 1;
           kingzone_gegner[i-10] = 1;
           kingzone_gegner[i-11] = 1;
           kingzone_gegner[i+9] = 1;
           kingzone_gegner[i+10] = 1;
           kingzone_gegner[i+11] = 1;}//*/
        /*  if ((abs(figur) == W_K||abs(figur) == W_Kr) && (feld[i]/abs(figur)) == farbe)
          {

              kingzone_ich[i] = 1;
          kingzone_ich[i+1] = 1;
          kingzone_ich[i-1] = 1;
          kingzone_ich[i-9] = 1;
          kingzone_ich[i-10] = 1;
          kingzone_ich[i-11] = 1;
          kingzone_ich[i+9] = 1;
          kingzone_ich[i+10] = 1;
          kingzone_ich[i+11] = 1;
          }//*/
    }

    return wert;
}

inline int zuganzahl(int feld[120], int _eigene_farbe)  { // Zaehlt Zuege von
    // Offizieren und
    // Bauern inclusive
    // Deckung und
    // Schlagen,
    // bei Bauern jedoch kein Schlagen
    // , was auch unterschiedlich gewichtet werden kann
    int pos2;
    int figur;
    int farbvorzeichen;
    int Attack = 0;
    double schlagzone_ich[120] = {0};
    double schlagzone_gegner[120] = {0};
    double n = 0;

    // disp(feld);
    for (int i = 21; i <= 98; i++)    {
        figur = abs(feld[i]);

        if (feld[i] > 0) {
            farbvorzeichen = +1;
        } else {
            farbvorzeichen = -1;
        }

        if ((figur == LEER) || (figur == RAND)) continue;

        if ((figur == W_D)) {
            int n_Dame      = -5;
            int Attack_Dame = 0;

            for (int richtung = 0; richtung <= bewegung[figur][0]; richtung++)  {
                for (int weite = 0; weite <= bewegung[figur][1]; weite++)  {
                    pos2 = i + farbvorzeichen * bewegung[figur][2 + richtung] * (weite + 1);
                    int zielfeld = feld[pos2];

                    /*    for (int richtung = 0; richtung <= bewegung[W_K][0]; richtung++)
                        {
                       for (int weite = 0; weite <= bewegung[W_K][1]; weite++)  {
                       pos2 = i + farbvorzeichen * bewegung[W_K][2+richtung] * (weite+1);
                       int zielfeldk = feld[pos2];
                       if (zielfeld == zielfeldk) n -= 400*farbvorzeichen;return n;}}*/

                    if (zielfeld != LEER)  {
                        int zielfigur = abs(zielfeld);
                        if (zielfeld == RAND) // Aus!
                            break;

                        /*   if (abs(zielfeld) == W_K)
                                break;*/

                        if (farbvorzeichen != _eigene_farbe)  {
                            if (zielfeld / _eigene_farbe > 0) {                // Gegner greift meine Figur an
                                if (schlagzone_gegner[pos2] != 1) schlagzone_gegner[pos2] = 1;
                                else Attack_Dame += KooIch; n_Dame = n_Dame + 1; // 12

                                if ((n_Dame > 8) && (n_Dame < 10)) n_Dame += 0.5;

                                Attack_Dame +=
                                        (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) * AttackIch;
                            }
                            else { Attack_Dame += DefIch1;

                                if (abs(zielfeld) < 6) Attack_Dame -= DefIch2; } // Gegner
                            // deckt
                            // seine
                            // Figuren
                            //    1
                        } else  {
                            if (zielfeld / _eigene_farbe < 0) {                     // Ich
                                // greife
                                // Gegner
                                // an
                                if (schlagzone_ich[pos2] != 1) schlagzone_ich[pos2] = 1;
                                else Attack_Dame += KooEr;

                                if (n_Dame < 9) n_Dame = n_Dame + 1;  // 12

                                if ((n_Dame > 8) && (n_Dame < 10)) n_Dame += 0.5;

                                if (zielfigur == W_K || zielfigur == W_Kr) continue;
                                Attack_Dame += (abs(zielfeld) * materialwert[abs(zielfeld)]) /
                                               AttackEr;
                            }
                            else  if (abs(zielfeld) <
                                      10) Attack_Dame +=
                                                  (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) / DefEr;
                        } // Ich decke meine Figuren
                        break;
                    }

                    if (farbvorzeichen != _eigene_farbe)  {

                        //         Attack_Dame += kingzone_ich[pos2] * Koenigsangriff_Er;

                        if (n_Dame < 9) n_Dame = n_Dame + 1;               // 12

                        if ((n_Dame > 8) && (n_Dame < 10)) n_Dame += 0.5;  // -12.5
                    } else  {
                        //  if (kingzone_gegner[pos2] == 1) cout << "HALLO" << kingzone_gegner[pos2] * Koenigsangriff_Ich << " \n";
                        //      Attack_Dame += kingzone_gegner[pos2] * Koenigsangriff_Ich;
                        if (n_Dame < 9) n_Dame = n_Dame + 1;               // 12

                        if ((n_Dame > 8) && (n_Dame < 10)) n_Dame += 0.5;
                    }
                }
            } n_Dame    *= farbvorzeichen;
            Attack_Dame *= farbvorzeichen;
            //  cout << MobDame * n_Dame + AttDame * Attack_Dame << "\n";
            n           += MobDame * n_Dame + AttDame * Attack_Dame;
        }

        if ((figur == W_T) || (figur == W_Tr)) {
            int n_Turm      = -10;
            int Attack_Turm = 0;

            for (int richtung = 0; richtung <= bewegung[figur][0]; richtung++)  {
                for (int weite = 0; weite <= bewegung[figur][1]; weite++)  {
                    pos2 = i + farbvorzeichen * bewegung[figur][2 + richtung] * (weite + 1);
                    int zielfeld = feld[pos2];

                    /*    for (int richtung = 0; richtung <= bewegung[W_K][0]; richtung++)
                        {
                       for (int weite = 0; weite <= bewegung[W_K][1]; weite++)  {
                       pos2 = i + farbvorzeichen * bewegung[W_K][2+richtung] * (weite+1);
                       int zielfeldk = feld[pos2];
                       if (zielfeld == zielfeldk) n -= 400*farbvorzeichen;return n;}}*/

                    if (zielfeld != LEER)  {
                        int zielfigur = abs(zielfeld);

                        if (zielfeld == RAND) // Aus!
                            break;

                        /*   if (abs(zielfeld) == W_K)
                                break;*/

                        if (farbvorzeichen != _eigene_farbe)  {
                            if (zielfeld / _eigene_farbe > 0) { // Gegner greift meine Figur
                                // an
                                if (schlagzone_gegner[pos2] != 1) schlagzone_gegner[pos2] = 1;
                                else Attack_Turm += KooIch;
                                n_Turm += 3;

                                if ((n_Turm > 6) && (n_Turm < 11)) n_Turm += 2;

                                if ((n_Turm > 10) && (n_Turm < 14)) n_Turm += 1;

                                Attack_Turm +=
                                        (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) * AttackIch;
                            }
                            else { Attack_Turm += DefIch1;

                                if (abs(zielfeld) < 6) Attack_Turm -= DefIch2; } // Gegner
                            // deckt
                            // seine
                            // Figuren
                            //    1
                        } else  {
                            if (zielfeld / _eigene_farbe < 0) {                     // Ich
                                // greife
                                // Gegner
                                // an
                                if (schlagzone_ich[pos2] != 1) schlagzone_ich[pos2] = 1;
                                else Attack_Turm += KooEr;

                                if (n_Turm < 7) n_Turm += 3;

                                if ((n_Turm > 6) && (n_Turm < 11)) n_Turm += 2;

                                if ((n_Turm > 10) && (n_Turm < 14)) n_Turm += 1;

                                if (zielfigur == W_K || zielfigur == W_Kr) continue;
                                Attack_Turm += (abs(zielfeld) * materialwert[abs(zielfeld)]) /
                                               AttackEr;
                            }
                            else  if (abs(zielfeld) <
                                      10) Attack_Turm +=
                                                  (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) / DefEr;
                        } // Ich decke meine Figuren
                        break;
                    }

                    if (farbvorzeichen != _eigene_farbe)  {
                        //         Attack_Turm += kingzone_ich[pos2] * Koenigsangriff_Er;

                        if (n_Turm < 7) n_Turm += 3;

                        if ((n_Turm > 6) && (n_Turm < 11)) n_Turm += 2;

                        if ((n_Turm > 10) && (n_Turm < 14)) n_Turm += 1;
                    }
                    else  {
                        //   Attack_Turm += kingzone_gegner[pos2] * Koenigsangriff_Ich;
                        if (n_Turm < 7) n_Turm += 3;

                        if ((n_Turm > 6) && (n_Turm < 11)) n_Turm += 2;

                        if ((n_Turm > 10) && (n_Turm < 14)) n_Turm += 1;
                    }
                }
            } n_Turm *= farbvorzeichen; Attack_Turm *= farbvorzeichen;
            n        += MobTurm * n_Turm + AttTurm * Attack_Turm;
        }

        if ((figur == W_L)) {
            int n_Laeufer      = -15;
            int Attack_Laeufer = 0;

            for (int richtung = 0; richtung <= bewegung[figur][0]; richtung++)  {
                for (int weite = 0; weite <= bewegung[figur][1]; weite++)  {
                    pos2 = i + farbvorzeichen * bewegung[figur][2 + richtung] * (weite + 1);
                    int zielfeld = feld[pos2];

                    /*    for (int richtung = 0; richtung <= bewegung[W_K][0]; richtung++)
                        {
                       for (int weite = 0; weite <= bewegung[W_K][1]; weite++)  {
                       pos2 = i + farbvorzeichen * bewegung[W_K][2+richtung] * (weite+1);
                       int zielfeldk = feld[pos2];
                       if (zielfeld == zielfeldk) n -= 400*farbvorzeichen;return n;}}*/

                    if (zielfeld != LEER)  {
                        int zielfigur = abs(zielfeld);

                        if (zielfeld == RAND) // Aus!
                            break;

                        /*   if (abs(zielfeld) == W_K)
                            break;*/

                        if (farbvorzeichen != _eigene_farbe)  {
                            if (zielfeld / _eigene_farbe > 0) { // Gegner greift meine Figur
                                // an
                                if (schlagzone_gegner[pos2] != 1) schlagzone_gegner[pos2] = 1;
                                else Attack_Laeufer += KooIch;

                                if (n_Laeufer == -15) n_Laeufer += 5;  // 12

                                if ((n_Laeufer > -11) && (n_Laeufer < 10)) n_Laeufer += 4;

                                if ((n_Laeufer > 9) && (n_Laeufer < 16)) n_Laeufer += 3;

                                if ((n_Laeufer > 15) && (n_Laeufer < 22)) n_Laeufer += 2;

                                if (n_Laeufer > 21) n_Laeufer += 1;

                                Attack_Laeufer +=
                                        (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) * AttackIch;
                            }
                            else { Attack_Laeufer += DefIch1;

                                if (abs(zielfeld) < 6) Attack_Laeufer -= DefIch2; } // Gegner
                            // deckt
                            // seine
                            // Figuren
                            //    1
                        } else  {
                            if (zielfeld / _eigene_farbe < 0) {                        // Ich
                                // greife
                                // Gegner
                                // an
                                if (schlagzone_ich[pos2] != 1) schlagzone_ich[pos2] = 1;
                                else Attack_Laeufer += KooEr;

                                if (n_Laeufer == -15) n_Laeufer += 5;  // 12

                                if ((n_Laeufer > -11) && (n_Laeufer < 10)) n_Laeufer += 4;

                                if ((n_Laeufer > 9) && (n_Laeufer < 16)) n_Laeufer += 3;

                                if ((n_Laeufer > 15) && (n_Laeufer < 22)) n_Laeufer += 2;

                                if (n_Laeufer > 21) n_Laeufer += 1;

                                if (zielfigur == W_K || zielfigur == W_Kr) continue;
                                Attack_Laeufer += (abs(zielfeld) * materialwert[abs(zielfeld)]) /
                                                  AttackEr;
                            }
                            else  if (abs(zielfeld) <
                                      10) Attack_Laeufer +=
                                                  (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) / DefEr;
                        } // Ich decke meine Figuren
                        break;
                    }

                    if (farbvorzeichen != _eigene_farbe)  {
                        //              Attack_Laeufer += kingzone_ich[pos2] * Koenigsangriff_Er;

                        if (n_Laeufer == -15) n_Laeufer += 5;  // 12

                        if ((n_Laeufer > -11) && (n_Laeufer < 10)) n_Laeufer += 4;

                        if ((n_Laeufer > 9) && (n_Laeufer < 16)) n_Laeufer += 3;

                        if ((n_Laeufer > 15) && (n_Laeufer < 22)) n_Laeufer += 2;

                        if (n_Laeufer > 21) n_Laeufer += 1;
                    }
                    else  {
                        //    Attack_Laeufer += kingzone_gegner[pos2] * Koenigsangriff_Ich;
                        if (n_Laeufer == -15) n_Laeufer += 5;  // 12

                        if ((n_Laeufer > -11) && (n_Laeufer < 10)) n_Laeufer += 4;

                        if ((n_Laeufer > 9) && (n_Laeufer < 16)) n_Laeufer += 3;

                        if ((n_Laeufer > 15) && (n_Laeufer < 22)) n_Laeufer += 2;

                        if (n_Laeufer > 21) n_Laeufer += 1;
                    }
                }
            } n_Laeufer *= farbvorzeichen; Attack_Laeufer *= farbvorzeichen;

            n += MobLau * n_Laeufer + AttLau * Attack_Laeufer;
        }

        if ((figur == W_P)) {
            int Attack_Pferd = 0;

            for (int richtung = 0; richtung <= bewegung[figur][0]; richtung++)  {
                for (int weite = 0; weite <= bewegung[figur][1]; weite++)  {
                    pos2 = i + farbvorzeichen * bewegung[figur][2 + richtung] * (weite + 1);
                    int zielfeld = feld[pos2];

                    /*    for (int richtung = 0; richtung <= bewegung[W_K][0]; richtung++)
                        {
                       for (int weite = 0; weite <= bewegung[W_K][1]; weite++)  {
                       pos2 = i + farbvorzeichen * bewegung[W_K][2+richtung] * (weite+1);
                       int zielfeldk = feld[pos2];
                       if (zielfeld == zielfeldk) n -= 400*farbvorzeichen;return n;}}*/

                    if (zielfeld != LEER)  {
                        int zielfigur = abs(zielfeld);

                        if (zielfeld == RAND) // Aus!
                            break;

                        /*   if (abs(zielfeld) == W_K)
                            break;*/

                        if (farbvorzeichen != _eigene_farbe)  {
                            if (zielfeld / _eigene_farbe > 0) { // Gegner greift meine Figur
                                // an
                                if (schlagzone_gegner[pos2] != 1) schlagzone_gegner[pos2] = 1;
                                else Attack_Pferd += KooIch;

                                Attack_Pferd +=
                                        (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) * AttackIch;
                            }
                            else { Attack_Pferd += DefIch1;

                                if (abs(zielfeld) < 6) Attack_Pferd -= DefIch2; } // Gegner
                            // deckt
                            // seine
                            // Figuren
                            //    1
                        } else  {
                            if (zielfeld / _eigene_farbe < 0) {                      // Ich
                                // greife
                                // Gegner
                                // an
                                if (schlagzone_ich[pos2] != 1) schlagzone_ich[pos2] = 1;
                                else Attack_Pferd += KooEr;

                                if (zielfigur == W_K || zielfigur == W_Kr) continue;
                                Attack_Pferd += (abs(zielfeld) * materialwert[abs(zielfeld)]) /
                                                AttackEr;
                            }
                            else  if (abs(zielfeld) <
                                      10) Attack_Pferd +=
                                                  (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) / DefEr;
                        } // Ich decke meine Figuren
                        break;
                    }

                    /*    if (farbvorzeichen != _eigene_farbe)  {
                    //            Attack_Pferd += kingzone_ich[pos2] * Koenigsangriff_Er;

                        }
                        else  {
                   //    Attack_Pferd += kingzone_gegner[pos2] * Koenigsangriff_Ich;
                        }//*/
                }
            } Attack_Pferd *= farbvorzeichen;

            n += AttSpr * Attack_Pferd;
        }

        if (((figur == W_B) || (figur == W_Bx))) {
            int Attack_Bauer = 0;

            for (int richtung = 0; richtung <= bewegung[13][0]; richtung++)  {
                for (int weite = 0; weite <= bewegung[13][1]; weite++)  {
                    pos2 = i + farbvorzeichen * bewegung[13][2 + richtung] * (weite + 1);
                    int zielfeld = feld[pos2];

                    /*    for (int richtung = 0; richtung <= bewegung[W_K][0]; richtung++)
                        {
                       for (int weite = 0; weite <= bewegung[W_K][1]; weite++)  {
                       pos2 = i + farbvorzeichen * bewegung[W_K][2+richtung] * (weite+1);
                       int zielfeldk = feld[pos2];
                       if (zielfeld == zielfeldk) n -= 400*farbvorzeichen;return n;}}_*/

                    if (zielfeld != LEER)  {
                        int zielfigur = abs(zielfeld);

                        if (zielfeld == RAND) // Aus!
                            break;

                        /*   if (abs(zielfeld) == W_K)
                                break;*/
                        if (farbvorzeichen != _eigene_farbe)  {
                            if (zielfeld / _eigene_farbe > 0) { // Gegner greift meine Figur
                                // an
                                if (schlagzone_gegner[pos2] != 1) schlagzone_gegner[pos2] = 1;
                                else Attack_Bauer += KooIch;

                                Attack_Bauer +=
                                        (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) * AttackIch;
                            }
                            else {
                                Attack_Bauer += DefIch1 / 2;
                                //         if (abs(zielfeld) < 6) Attack_Bauer -= DefIch2;
                            }                                   // Gegner deckt seine Figuren
                            //    1
                        } else  {
                            if (zielfeld / _eigene_farbe < 0) { // Ich greife Gegner an
                                if (schlagzone_ich[pos2] != 1) schlagzone_ich[pos2] = 1;
                                else Attack_Bauer += KooEr;

                                if (zielfigur == W_K || zielfigur == W_Kr) continue;
                                Attack_Bauer += (abs(zielfeld) * materialwert[abs(zielfeld)]) /
                                                AttackEr;
                            }
                            else {

                                if (abs(zielfeld) <
                                    10) Attack_Bauer +=
                                                (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) /
                                                DefEr;
                                //    if (abs(zielfeld) < 6) Attack_Bauer -= DefIch2;
                            }
                        } // Ich decke meine Figuren
                        break;
                    }

                    /*       if (farbvorzeichen != _eigene_farbe)  {
                        //             Attack_Bauer += kingzone_ich[pos2] * Koenigsangriff_Er;

                           }
                           else  {
                    //    Attack_Bauer += kingzone_gegner[pos2] * Koenigsangriff_Ich;
                           }//*/
                }
            } Attack_Bauer *= farbvorzeichen;

            n += AttBau * Attack_Bauer;
        }

        if (((figur == W_K) || (figur == W_Kr))) {
            int Attack_Koenig = 0;

            // int KSafety = 0;

            for (int richtung = 0; richtung <= bewegung[figur][0]; richtung++)  {
                for (int weite = 0; weite <= bewegung[figur][1]; weite++)  {
                    pos2 = i + farbvorzeichen * bewegung[figur][2 + richtung] * (weite + 1);
                    int zielfeld = feld[pos2];

                    /*    for (int richtung = 0; richtung <= bewegung[W_K][0]; richtung++)
                        {
                       for (int weite = 0; weite <= bewegung[W_K][1]; weite++)  {
                       pos2 = i + farbvorzeichen * bewegung[W_K][2+richtung] * (weite+1);
                       int zielfeldk = feld[pos2];
                       if (zielfeld == zielfeldk) n -= 400*farbvorzeichen;return n;}}*/

                    if (zielfeld != LEER)  {
                        int zielfigur = abs(zielfeld);

                        if (zielfeld == RAND) // Aus!
                            break;

                        /*   if (abs(zielfeld) == W_K)
                                   break;*/
                        if (farbvorzeichen != _eigene_farbe)  {
                            /*if (OpenLines[i%10-2] == 1) KSafety -= 550;
                                        if (OpenLines[i%10] == 1) KSafety -= 550;
                                        if (OpenLines[i%10-1] == 1) KSafety -= 550;//*/
                            if (zielfeld / _eigene_farbe > 0) { // Gegner greift meine Figur an
                                if (schlagzone_gegner[pos2] != 1) schlagzone_gegner[pos2] = 1;
                                else Attack_Koenig += KooIch;
                                Attack_Koenig += (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) * AttackIch;
                            }
                            else Attack_Koenig += DefIch1;
                            // Gegner deckt seine Figuren    1
                        } else  {
                            /*if (OpenLines[i%10-2] == 1) KSafety -= 550;
                                     if (OpenLines[i%10] == 1) KSafety -= 550;
                                     if (OpenLines[i%10-1] == 1) KSafety -= 550;//*/
                            if (zielfeld / _eigene_farbe < 0) { // Ich greife Gegner an
                                if (schlagzone_ich[pos2] != 1) schlagzone_ich[pos2] = 1;
                                else Attack_Koenig += KooEr;

                                if (zielfigur == W_K) continue;
                                Attack_Koenig += (abs(zielfeld) * materialwert[abs(zielfeld)]) / AttackEr;
                            }
                            else  if (abs(zielfeld) < 10) Attack_Koenig += (abs(zielfeld) * materialwert[abs(zielfeld)] - 40) / DefEr;
                        } // Ich decke meine Figuren
                        break;
                    }

                    /*     if (farbvorzeichen != _eigene_farbe)  {
                      Attack_Koenig += kingzone_ich[pos2] * Koenigsangriff_Er;

                         }
                         else  {
                           Attack_Koenig += kingzone_gegner[pos2] * Koenigsangriff_Ich;
                         }//*/
                }
            } Attack_Koenig *= farbvorzeichen;

            // KSafety *= farbvorzeichen;
            // cout << KSafety << "\n";
            n += AttKoe * Attack_Koenig; // + KSafety;
        }
    }

    return n;
}

int sort(denkpaar _zugstapel[200], int _n, int _stufe)  { // Sortiert Zugstapel neu nach Schema
    int zid;
    int m = 0; // Wieviele Z¬∏ge sind umsortiert?
    denkpaar temp;

    for (int j = 0; j < 200; j++)  {
        zid = sort_schema[_stufe][j]; // Was ist mein j.ter Zug im Schema?

        if (zid == 0) {
            break;
        }

        for (int i = 0; i < _n; i++) {      // vergleichen mit zugstapel
            if (_zugstapel[i].z.id == zid)  { // An welcher Position ist der im Zugstapel?
                temp          = _zugstapel[i];  // Vertausche den Zug
                _zugstapel[i] = _zugstapel[m];
                _zugstapel[m] = temp;
                m++;
                break; // und weiter...
            }
        }
    }
    return 0;
}

int make_schema(denkpaar _zugstapel[200], int _n, int _stufe)  {
    for (int j = 0; j < (sortiertiefe - 1); j++)  {                   // Sortiertiefe == wieviele Züge sollen sortiert werden?
        denkpaar temp;

        if (best_one[_stufe].z.id == 0)                                 // Gibt es
            // keinen
            // PV-Zug?
            break;

        if (sort_schema_bewertung[_stufe][j].z.id == 0)  {              // wenn es noch keinen vorsortieren Zug gibt:
            sort_schema_bewertung[_stufe][j]          = best_one[_stufe]; // nimm den PV-Zug
            sort_schema_bewertung[_stufe][j + 1].z.id = 0;                // setze den
            // nächstsortierten
            // Zug auf 0
            break;
        }

        if (best_one[_stufe].z.id == sort_schema_bewertung[_stufe][j].z.id)  { // wenn
            // der
            // PV-Zug
            // mit
            // dem
            // vorsortierten
            // Zug
            // identisch
            // ist
            sort_schema_bewertung[_stufe][j].bewertung *= 9;
            break;
        }

        /*cout << "Vorsortierung:" <<
           grundfeld_bezeichnungen[best_one[_stufe].z.pos.pos1] <<
           grundfeld_bezeichnungen[best_one[_stufe].z.pos.pos2] << "\n*/
        if (best_one[_stufe].bewertung >
            sort_schema_bewertung[_stufe][j].bewertung)  {
            // Wenn Bewertung des best_one besser --> einordnen
            temp                             = sort_schema_bewertung[_stufe][j];
            sort_schema_bewertung[_stufe][j] = best_one[_stufe];
            int i;

            for (i = 1; i < (sortiertiefe - j); i++)  {
                // Nach hinten schieben
                if (!sort_schema_bewertung[_stufe][j + i].z.id == 0)  {
                    sort_schema_bewertung[_stufe][j + i] = temp;
                    temp                                 =
                            sort_schema_bewertung[_stufe][j + i + 1];
                } else  {
                    sort_schema_bewertung[_stufe][j + i] = temp;
                    break;
                }
            }
            sort_schema_bewertung[_stufe][j + 1 + i].z.id = 0;
            break; // Abrechen, nachdem  e i n  zug eingeordnet ist.
            //	cout << best_one[_stufe].z.id << "\n";
        }        // */
    }

    for (int l = 0; l < 200; l++)  {
        if (sort_schema_bewertung[_stufe][l].z.id == 0)  {
            sort_schema[_stufe][l] = 0;
            break;
        }
        sort_schema[_stufe][l] = sort_schema_bewertung[_stufe][l].z.id;
    }
    return 0;
}

int move_sort_schema(int c = 6)  { // Schema 2 Z¬∏ge nach vorn schieben
    for (int i = 0; i < c; i++)  {
        for (int e = 1; e < ende; e++)  {
            for (int j = 0; j < sortiertiefe; j++)  {
                sort_schema_bewertung[e - 1][j] = sort_schema_bewertung[e][j]; // übernimm sort_schema-bewertung eine Stufe niedriger
                //	sort_schema_bewertung[e-1][j].bewertung *= 0,1; //multipliziere
                // es mit 0,0000000001
                sort_schema[e - 1][j] = sort_schema[e][j];                     // übernimm das Schema eine Stufe niedriger

                /*	sort_schema_bewertung[e-1][j].z.id  = 0;
                   sort_schema[e-1][j]			  = 0;		*/
            }
        }
    }
    return 0;
}